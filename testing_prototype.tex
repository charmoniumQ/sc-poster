\begin{block}{Testing Prototype and Experimental Setup}
  \begin{itemize}
    \item \textbf{Workload}
      \begin{itemize}
      \item Hand-optimized, in-memory, columnar, chunk-oriented operator
        implementations
    \begin{itemize}
    \item sorting, selection (filter), creating, and freeing tables
      \end{itemize}
  \item We report \textbf{sorting} a relation consisting of 256 chunks:
    \begin{itemize}
    \item intra chunk: sort data using counting sort
    \item inter chunk: merge sort
    \item two sorting variants: row-oriented versus column-oriented
\end{itemize}
    % splitting the input into chunks, applying counting sort per chunk, and merge sort to sort across chunks
\item We vary the number of columns in the table and the size of chunks
\item We report averages of 10 runes (and variance in some figures)
  % \end{itemize}
  % \item Basic array operations: allocate, set all, get all, copy, and free
  \end{itemize}
\item \textbf{Parameters and Inputs}
  \begin{itemize}
  \item Tables are stored in a column-oriented fashion, the data of a columns is split into 256 chunks - each is an array of data values of a fixed size 
  \item \textbf{\#columns}: between 2 and 128
  \item \textbf{\#chunks}: 256
  \item \textbf{chunk size (\#elements)}: between 256 ($2^8$) and 16,384 ($2^{14}$)
  \end{itemize}
\item \textbf{Compared Configurations}
    \begin{itemize}
    \item Hybrid runtime using Nautilus~\cite{HALE:2015:NAUTILUS} versus as application in Linux 
    \end{itemize}
  \item \textbf{Setup}
    \begin{itemize}
    \item hardware: 16-core x86\_64 AMD EPYC with 4 NUMA nodes
    \item OS: linux kernel 4.17.6, Nautilus - git commit \texttt{9df0e062}
    \end{itemize}
  \end{itemize}
\end{block}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
