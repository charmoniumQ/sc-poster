\begin{block}{Motivation and Background}




\underline{\textbf{Status quo}}
  \begin{itemize}
  \item General purpose OS and DBs% not aware of the workload; app-programmer is.
    \begin{itemize}
    \item broad interface for generality
    \item high-level abstractions for programmability
    \end{itemize}
%      use specialized scheduling and memory management abstractions.
 %   \item DBs suffer from over lack of specialization
    \item Too many abstractions $\implies$ high-performance is difficult to achieve
    \end{itemize}
    \begin{center}
 \alert{\textbf{Solution:} Give up flexibility and generality in exchange for performance}
\end{center}
%\\[7mm]
    
\underline{\textbf{Specialized Hybrid Runtimes}}
    \begin{itemize}
    \item Kernel + Dataflow Runtime run in ring 0 (unikernel-like).
    \item Resources can be split between general purpose OS and hybrid runtime
      \begin{itemize}
      \item $\implies$ can use general purpose OS where needed
    \end{itemize}

      % Advances in multi-kernel environments allow physical \todo{(cite pisces)} resources to be split between a full-weight kernel and a hybrid runtime.
      % \item \alert{Unikernel-inspired design prevents the OS from `getting in the way' of the app-programmer.}
    \item {Unikernel-inspired design gives programmer fine-grained control over \ldots}
      \begin{itemize}
      \item scheduling $\implies$ no context-switches
      \item OS $\implies$ avoid interrupts $\implies$ faster and more predictable
      \item No virtual memory $\implies$ huge page-sizes (1Gb) $\implies$ no TLB misses.
      \item memory allocation $\implies$ specialize allocator for workload/application (see Fig.~ \ref{fig:1})
      \end{itemize}
    \end{itemize}

    \underline{\textbf{Compiled Query Processing}}
    \begin{itemize}
    \item DB engine is specialized for a particular query
      \begin{itemize}
      \item Smaller code $\implies$ less instruction cache misses and branches
      \item Specialize data structures to data and query characteristics $\implies$ have the best fit data structure for every situation
      \item Combine code for multiple operators (pipeline) $\implies$ enables cross operator optimizations and avoids function call overhead
      \item Specialize code for hardware without blowing up code size
      \end{itemize}
    % \item {The app-programmer writes compiled code in the unikernel, giving them unfettered access HW.}
    %   \begin{itemize}
    %   \item Compose operators within a block $\implies$ avoid function-call overhead.
    %   \item Control HW $\implies$ NUMA-aware code.
    %   \end{itemize}
    \end{itemize}
\end{block}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
