\begin{block}{Motivation and Background}

\underline{\textbf{Status quo}}
  \begin{itemize}
  \item \textbf{General purpose OS and DBs}% not aware of the workload; app-programmer is.
    \begin{itemize}
     \item \textbf{Too many abstractions over HW} $\implies$ high-performance is difficult
      to achieve~\cite{GICEVA:2016:OS_SUPPORT,HALE:2015:NAUTILUS}
    \item not workload aware; optimized for the general case (lowest common denominator)
    \item Time-sharing kernel $\implies$ context-switches, scheduling interrupts, and thread-migration
    % \begin{itemize}
    % % \item high-level abstractions for programmability
    % \item $\implies$ context-switches, scheduling interrupts, and thread-migration
    % \end{itemize}
    \item Separation of kernel and user space $\implies$ more context switches
    \end{itemize}
%      use specialized scheduling and memory management abstractions.
 %   \item DBs suffer from over lack of specialization
  \item \textbf{General purpose DB}
    \begin{itemize}
    \item Interpreted query and expression evaluation  $\implies$
      \begin{itemize}
      \item Deep function-call trees
    \item Poor spacial locality in instruction memory
    \end{itemize}
    \end{itemize}
  \end{itemize}

  \begin{center}
    \alert{\textbf{Solution:} Give up flexibility and generality in exchange for performance}
  \end{center}
   
  \underline{\textbf{Specialized Hybrid Runtimes}~\cite{HALE:2015:NAUTILUS}}
    \begin{itemize}
    \item Kernel + Dataflow Runtime run in ring 0 (unikernel-like).
    \item Physical resources can be partitioned between general purpose OS and hybrid runtime~\cite{KOCOLOSKI:2015:PISCES}.
      \begin{itemize}
      \item $\implies$ can call general purpose OS where needed.
      \end{itemize}

      % Advances in multi-kernel environments allow physical \todo{(cite pisces)} resources to be split between a full-weight kernel and a hybrid runtime.
      % \item \alert{Unikernel-inspired design prevents the OS from `getting in the way' of the app-programmer.}
    \item {Unikernel-inspired design gives programmer fine-grained control over \ldots}
      \begin{itemize}
      \item Not time-shared $\implies$ No context-switches or thread-migration.
      \item Avoid interrupts $\implies$ faster and more predictable
      \item Single address space $\implies$ huge page-sizes (1Gb) $\implies$ no TLB misses.
      \item Memory allocation $\implies$ specialize allocator for workload/application (see Fig. \ref{fig:malloc})
      \end{itemize}
    \end{itemize}
  
    \underline{\textbf{Compiled Query Processing}~\cite{SK16,N11}}
    \begin{itemize}
    \item DB engine is specialized for a particular query
      \begin{itemize}
      \item Smaller code $\implies$ less instruction cache misses and branches
      \item Specialize data structures to data and query characteristics $\implies$ have the best fit data structure for every situation
      \item Combine code for multiple operators (pipeline) $\implies$ enables cross operator optimizations and avoids function call overhead
      \item Specialize code for hardware without blow up in code size
      \end{itemize}
    % \item {The app-programmer writes compiled code in the unikernel, giving them unfettered access HW.}
    %   \begin{itemize}
    %   \item Compose operators within a block $\implies$ avoid function-call overhead.
    %   \item Control HW $\implies$ NUMA-aware code.
    %   \end{itemize}
    \end{itemize}
\end{block}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
